import { Interview, InterviewResults, JobDescription, Candidate, ResumeUploadResponse, AddCandidateRequest } from '../types';
import { supabase } from './supabase';

export interface N8nWorkflowResponse {
  success: boolean;
  data?: any;
  error?: string;
}

export interface QuestionGenerationRequest {
  jobDescription: JobDescription;
  candidateResume: string;
  interviewId: string;
}

export interface QuestionGenerationResponse {
  questions: string[];
  followUpQuestions: string[];
  evaluationCriteria: string[];
}

export interface LiveInterviewRequest {
  interviewId: string;
  candidateId: string;
  questions: string[];
  jobDescription: JobDescription;
}

export interface LiveInterviewResponse {
  sessionId: string;
  status: 'initialized' | 'active' | 'completed' | 'error';
  message?: string;
}

export interface EvaluationRequest {
  interviewId: string;
  transcript: string;
  questions: string[];
  jobDescription: JobDescription;
}

export interface EvaluationResponse {
  overallScore: number;
  communicationScore: number;
  technicalScore: number;
  adaptabilityScore: number;
  evaluation: string;
  recommendations: string[];
}

export interface ExtractedResumeData {
  name: string;
  email: string;
  phone: string;
  summary: string;
  resume_description: string;
  skills: string[];
  experience: any[] | string;
  education: any[] | string;
  projects: any[];
}

export class N8nService {
  private static baseUrl = process.env.REACT_APP_N8N_BASE_URL || 'https://home.ausomemgr.com';
  private static apiKey = process.env.REACT_APP_N8N_API_KEY || 'your-api-key';
  private static resumeWebhookUrl = process.env.REACT_APP_N8N_RESUME_PARSER_WEBHOOK || process.env.REACT_APP_N8N_RESUME_WEBHOOK || 'https://home.ausomemgr.com/webhook-test/parse-resume';

  // Note: Custom candidate_id is generated by your existing system
  // We'll let Supabase handle the candidate_id generation

  // Generate questions for interview
  static async generateQuestions(request: QuestionGenerationRequest): Promise<QuestionGenerationResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/webhook/question-generation`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          jobDescription: request.jobDescription,
          candidateResume: request.candidateResume,
          interviewId: request.interviewId,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to generate questions');
      }

      return {
        questions: data.questions || [],
        followUpQuestions: data.followUpQuestions || [],
        evaluationCriteria: data.evaluationCriteria || [],
      };
    } catch (error) {
      console.error('Error generating questions:', error);
      throw new Error('Failed to generate interview questions');
    }
  }

  // Initialize live interview session
  static async initializeLiveInterview(request: LiveInterviewRequest): Promise<LiveInterviewResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/webhook/live-interview-init`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          interviewId: request.interviewId,
          candidateId: request.candidateId,
          questions: request.questions,
          jobDescription: request.jobDescription,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to initialize live interview');
      }

      return {
        sessionId: data.sessionId,
        status: data.status,
        message: data.message,
      };
    } catch (error) {
      console.error('Error initializing live interview:', error);
      throw new Error('Failed to initialize live interview session');
    }
  }

  // Send voice data to n8n for processing
  static async processVoiceData(sessionId: string, audioData: Blob): Promise<N8nWorkflowResponse> {
    try {
      const formData = new FormData();
      formData.append('sessionId', sessionId);
      formData.append('audioData', audioData);
      formData.append('timestamp', new Date().toISOString());

      const response = await fetch(`${this.baseUrl}/webhook/voice-processing`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error('Error processing voice data:', error);
      return {
        success: false,
        error: 'Failed to process voice data',
      };
    }
  }

  // Get next question from AI
  static async getNextQuestion(sessionId: string, candidateResponse?: string): Promise<{ question: string; isComplete: boolean }> {
    try {
      const response = await fetch(`${this.baseUrl}/webhook/get-next-question`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          sessionId,
          candidateResponse,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to get next question');
      }

      return {
        question: data.question,
        isComplete: data.isComplete || false,
      };
    } catch (error) {
      console.error('Error getting next question:', error);
      throw new Error('Failed to get next question');
    }
  }

  // Complete interview session
  static async completeInterview(sessionId: string): Promise<N8nWorkflowResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/webhook/complete-interview`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          sessionId,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error('Error completing interview:', error);
      return {
        success: false,
        error: 'Failed to complete interview',
      };
    }
  }

  // Evaluate interview results
  static async evaluateInterview(request: EvaluationRequest): Promise<EvaluationResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/webhook/evaluate-interview`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          interviewId: request.interviewId,
          transcript: request.transcript,
          questions: request.questions,
          jobDescription: request.jobDescription,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to evaluate interview');
      }

      return {
        overallScore: data.overallScore,
        communicationScore: data.communicationScore,
        technicalScore: data.technicalScore,
        adaptabilityScore: data.adaptabilityScore,
        evaluation: data.evaluation,
        recommendations: data.recommendations || [],
      };
    } catch (error) {
      console.error('Error evaluating interview:', error);
      throw new Error('Failed to evaluate interview');
    }
  }

  // Process resume from URL through n8n workflow
  static async processResumeFromUrl(resumeUrl: string, candidateName?: string): Promise<ResumeUploadResponse> {
    try {
      const requestData = {
        resume_url: resumeUrl,
        candidate_name: candidateName || '',
        analysis_type: 'comprehensive',
        timestamp: new Date().toISOString()
      };

      console.log('Sending resume URL to webhook:', this.resumeWebhookUrl);
      console.log('Resume URL:', resumeUrl);

      const response = await fetch(this.resumeWebhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
      });

      console.log('Webhook response status:', response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Webhook error response:', errorText);
        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log('Webhook response data:', data);
      
      // Handle different response formats from n8n
      if (data.success === false || data.error) {
        throw new Error(data.error || 'Failed to process resume from URL');
      }

      // Store candidate data in Supabase
      // Handle both old format and new structured format from improved resume parser
      let extractedData: ExtractedResumeData;
      
      if (data.analysis || data.extractedData) {
        // New structured format from improved resume parser
        const analysisData = data.analysis || data.extractedData;
        extractedData = {
          name: analysisData.name || '',
          email: analysisData.email || '',
          phone: analysisData.phone || '',
          summary: analysisData.summary || '',
          resume_description: analysisData.resume_description || '',
          skills: data.skills || [], // Flattened skills array from processor
          experience: analysisData.experience || [],
          education: analysisData.education || [],
          projects: analysisData.projects || []
        };
      } else {
        // Legacy format fallback
        extractedData = {
          name: data.name || data.candidateName || candidateName || '',
          email: data.email || data.candidateEmail || '',
          phone: data.phone || data.candidatePhone || '',
          summary: data.summary || '',
          resume_description: data.resume_description || '',
          skills: data.skills || [],
          experience: data.experience || '',
          education: data.education || '',
          projects: []
        };
      }

      // Convert experience and education arrays to strings for database storage
      const experienceString = Array.isArray(extractedData.experience) 
        ? extractedData.experience.map(exp => `${exp.title} at ${exp.company} (${exp.duration}): ${exp.description}`).join('\n\n')
        : extractedData.experience || '';

      const educationString = Array.isArray(extractedData.education)
        ? extractedData.education.map(edu => `${edu.degree} from ${edu.institution}${edu.graduation_year ? ` (${edu.graduation_year})` : ''}`).join('\n\n')
        : extractedData.education || '';

      const projectsString = Array.isArray(extractedData.projects)
        ? extractedData.projects.map(proj => `${proj.title}: ${proj.description}${proj.technologies_used?.length ? ` (Technologies: ${proj.technologies_used.join(', ')})` : ''}`).join('\n\n')
        : '';

      // Generate candidate ID in format AS-{NAME_ABBREVIATION}-{LAST4_CONTACT}-{TIMESTAMP}
      const generateCandidateId = (name: string, phone?: string): string => {
        const words = name.split(' ').filter(word => word.length > 0);
        let abbreviation = '';
        
        if (words.length >= 2) {
          abbreviation = words.slice(0, 2).map(word => word.charAt(0).toUpperCase()).join('');
        } else if (words.length === 1) {
          abbreviation = words[0].substring(0, 3).toUpperCase();
        } else {
          abbreviation = 'CAN';
        }
        
        // Extract last 4 digits from phone number
        const phoneDigits = phone ? phone.replace(/\D/g, '') : '';
        const last4Contact = phoneDigits.slice(-4) || '0000';
        
        const timestamp = Date.now().toString().slice(-4);
        return `AS-${abbreviation}-${last4Contact}-${timestamp}`;
      };

      const candidateId = generateCandidateId(extractedData.name, extractedData.phone);

      // Save to Supabase
      const { data: candidateData, error: dbError } = await supabase
        .from('candidates')
        .insert({
          candidate_id: candidateId,
          name: extractedData.name,
          email: extractedData.email,
          phone: extractedData.phone,
          contact_number: extractedData.phone, // Also populate contact_number
          resume_url: resumeUrl, // Store the original resume URL
          resume_text: data.extracted_text || data.resumeText || data.extractedText || '',
          summary: extractedData.summary,
          resume_summary: extractedData.resume_description, // Store AI-generated description
          skills: extractedData.skills,
          experience: experienceString,
          education: educationString,
          projects: projectsString,
          status: 'active'
        })
        .select()
        .single();

      if (dbError) {
        console.error('Error saving candidate to database:', dbError);
        throw new Error(`Database error: ${dbError.message}`);
      }

      return {
        success: true,
        candidateId: candidateData?.id || 'generated-id',
        resumeText: data.extracted_text || data.resumeText || data.extractedText || '',
        extractedData: extractedData,
      };

    } catch (error) {
      console.error('Error processing resume from URL:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to process resume from URL',
      };
    }
  }

  // Process resume upload
  static async processResumeUpload(resumeFile: File): Promise<ResumeUploadResponse> {
    try {
      const formData = new FormData();
      
      // Add the resume file in binary format
      formData.append('resume', resumeFile, resumeFile.name);
      
      // Add file metadata for processing
      formData.append('timestamp', new Date().toISOString());
      formData.append('fileName', resumeFile.name);
      formData.append('fileSize', resumeFile.size.toString());
      formData.append('fileType', resumeFile.type);

      console.log('Sending resume to webhook:', this.resumeWebhookUrl);
      console.log('File details:', {
        name: resumeFile.name,
        size: resumeFile.size,
        type: resumeFile.type
      });

      const response = await fetch(this.resumeWebhookUrl, {
        method: 'POST',
        body: formData,
      });

      console.log('Webhook response status:', response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Webhook error response:', errorText);
        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log('Webhook response data:', data);
      
      // Handle different response formats from n8n
      if (data.success === false || data.error) {
        throw new Error(data.error || 'Failed to process resume');
      }

      // Store candidate data in Supabase
      // Handle both old format and new structured format from improved resume parser
      let extractedData: ExtractedResumeData;
      
      if (data.extractedData) {
        // New structured format from improved resume parser
        extractedData = {
          name: data.extractedData.name || '',
          email: data.extractedData.email || '',
          phone: data.extractedData.phone || '',
          summary: data.extractedData.summary || '',
          resume_description: data.extractedData.resume_description || '',
          skills: data.skills || [], // Flattened skills array from processor
          experience: data.extractedData.experience || [],
          education: data.extractedData.education || [],
          projects: data.extractedData.projects || []
        };
      } else {
        // Legacy format fallback
        extractedData = {
          name: data.name || data.candidateName || '',
          email: data.email || data.candidateEmail || '',
          phone: data.phone || data.candidatePhone || '',
          summary: data.summary || '',
          resume_description: data.resume_description || '',
          skills: data.skills || [],
          experience: data.experience || '',
          education: data.education || '',
          projects: []
        };
      }

      // Convert experience and education arrays to strings for database storage
      const experienceString = Array.isArray(extractedData.experience) 
        ? extractedData.experience.map(exp => `${exp.title} at ${exp.company} (${exp.duration}): ${exp.description}`).join('\n\n')
        : extractedData.experience || '';

      const educationString = Array.isArray(extractedData.education)
        ? extractedData.education.map(edu => `${edu.degree} from ${edu.institution}${edu.graduation_year ? ` (${edu.graduation_year})` : ''}`).join('\n\n')
        : extractedData.education || '';

      const projectsString = Array.isArray(extractedData.projects)
        ? extractedData.projects.map(proj => `${proj.title}: ${proj.description}${proj.technologies_used?.length ? ` (Technologies: ${proj.technologies_used.join(', ')})` : ''}`).join('\n\n')
        : '';

      // Generate candidate ID in format AS-{NAME_ABBREVIATION}-{LAST4_CONTACT}-{TIMESTAMP}
      const generateCandidateId = (name: string, phone?: string): string => {
        const words = name.split(' ').filter(word => word.length > 0);
        let abbreviation = '';
        
        if (words.length >= 2) {
          abbreviation = words.slice(0, 2).map(word => word.charAt(0).toUpperCase()).join('');
        } else if (words.length === 1) {
          abbreviation = words[0].substring(0, 3).toUpperCase();
        } else {
          abbreviation = 'CAN';
        }
        
        // Extract last 4 digits from phone number
        const phoneDigits = phone ? phone.replace(/\D/g, '') : '';
        const last4Contact = phoneDigits.slice(-4) || '0000';
        
        const timestamp = Date.now().toString().slice(-4);
        return `AS-${abbreviation}-${last4Contact}-${timestamp}`;
      };

      const candidateId = generateCandidateId(extractedData.name, extractedData.phone);

      // Save to Supabase
      const { data: candidateData, error: dbError } = await supabase
        .from('candidates')
        .insert({
          candidate_id: candidateId,
          name: extractedData.name,
          email: extractedData.email,
          phone: extractedData.phone,
          contact_number: extractedData.phone, // Also populate contact_number
          resume_url: data.resumeUrl || data.resume_url || '', // Store resume URL if available
          resume_text: data.resumeText || data.extractedText || '',
          summary: extractedData.summary,
          resume_summary: extractedData.resume_description, // Store AI-generated description
          skills: extractedData.skills,
          experience: experienceString,
          education: educationString,
          projects: projectsString,
          status: 'active'
        })
        .select()
        .single();

      if (dbError) {
        console.error('Error saving candidate to database:', dbError);
        // Still return success since n8n processing worked
      }

      return {
        success: true,
        candidateId: candidateData?.id || data.candidateId || data.id || 'generated-id',
        resumeText: data.resumeText || data.extractedText || '',
        extractedData: extractedData,
      };
    } catch (error) {
      console.error('Error processing resume:', error);
      return {
        success: false,
        error: `Failed to process resume: ${error instanceof Error ? error.message : 'Unknown error'}. Please try again or add candidate manually.`,
      };
    }
  }

  // Add candidate manually
  static async addCandidateManually(candidateData: AddCandidateRequest): Promise<{ success: boolean; candidateId?: string; error?: string }> {
    try {
      // Generate candidate ID in format AS-{NAME_ABBREVIATION}-{LAST4_CONTACT}-{TIMESTAMP}
      const generateCandidateId = (name: string, phone?: string): string => {
        const words = name.split(' ').filter(word => word.length > 0);
        let abbreviation = '';
        
        if (words.length >= 2) {
          abbreviation = words.slice(0, 2).map(word => word.charAt(0).toUpperCase()).join('');
        } else if (words.length === 1) {
          abbreviation = words[0].substring(0, 3).toUpperCase();
        } else {
          abbreviation = 'CAN';
        }
        
        // Extract last 4 digits from phone number
        const phoneDigits = phone ? phone.replace(/\D/g, '') : '';
        const last4Contact = phoneDigits.slice(-4) || '0000';
        
        const timestamp = Date.now().toString().slice(-4);
        return `AS-${abbreviation}-${last4Contact}-${timestamp}`;
      };

      const candidateId = generateCandidateId(candidateData.name, candidateData.phone);

      // Save candidate directly to Supabase
      const { data: newCandidate, error: dbError } = await supabase
        .from('candidates')
        .insert({
          candidate_id: candidateId,
          name: candidateData.name,
          email: candidateData.email,
          phone: candidateData.phone,
          contact_number: candidateData.phone, // Also populate contact_number
          resume_url: candidateData.resume_url || '', // Store resume URL if provided
          skills: candidateData.skills || [],
          experience: candidateData.experience || '',
          education: candidateData.education || '',
          resume_summary: candidateData.resume_description || '', // Store AI-generated description
          status: 'active'
        })
        .select()
        .single();

      if (dbError) {
        console.error('Error saving candidate to database:', dbError);
        throw new Error(`Database error: ${dbError.message}`);
      }

      // Optionally send to n8n for additional processing
      try {
        const response = await fetch(`${this.baseUrl}/webhook/add-candidate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`,
          },
          body: JSON.stringify({
            ...candidateData,
            candidateId: newCandidate.id,
            timestamp: new Date().toISOString(),
          }),
        });

        if (!response.ok) {
          console.warn('n8n webhook failed, but candidate was saved to database');
        }
      } catch (webhookError) {
        console.warn('n8n webhook error:', webhookError);
        // Continue since candidate was saved to database
      }

      return {
        success: true,
        candidateId: newCandidate.id,
      };
    } catch (error) {
      console.error('Error adding candidate:', error);
      return {
        success: false,
        error: `Failed to add candidate: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  // Test n8n connection
  static async testConnection(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/webhook/health-check`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
        },
      });

      return response.ok;
    } catch (error) {
      console.error('Error testing n8n connection:', error);
      return false;
    }
  }
}
